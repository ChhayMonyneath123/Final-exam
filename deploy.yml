---
- name: Deploy and configure web server pod
  hosts: localhost
  gather_facts: no
  vars:
    pod_name: ""  # This will be set dynamically after retrieving the pod name
    mysql_root_password: "Hello@123"  # MySQL root password
    mysql_database: "ChhayMonyneath-db"  # MySQL database name
    backup_path: "/home/neath/Documents/DevOps/Final-Exam/backup.sql"  # Backup file location
    git_repo_url: "https://github.com/ChhayMonyneath123/Final-exam.git"  # GitHub repository URL

  tasks:
    # Step 1: Get the current running pod name dynamically based on the label
    - name: Get the current running pod name
      shell: kubectl get pods -l app=laravel -o jsonpath='{.items[0].metadata.name}'
      register: current_pod
      changed_when: false
      failed_when: current_pod.rc != 0 or current_pod.stdout == ""

    - name: Set the pod name variable
      set_fact:
        pod_name: "{{ current_pod.stdout }}"

    - name: Display the pod name
      debug:
        msg: "Working with pod: {{ pod_name }}"

    # Step 2: Check if git is installed
    - name: Check if git is installed in the web-server container
      shell: |
        kubectl exec {{ pod_name }} -c web-server -- bash -c "command -v git"
      register: git_check
      changed_when: false
      ignore_errors: true

    # Step 3: Fix broken dependencies and install git
    - name: Fix broken dependencies and install git in the web-server container
      shell: |
        kubectl exec {{ pod_name }} -c web-server -- bash -c "apt-get update && apt-get install -y --fix-broken && apt-get install -y git"
      when: git_check.rc != 0 or git_check.stdout == ""
      changed_when: true
      ignore_errors: true  # Allow retry if it fails initially

    # Step 4: Clone Git repository if not present
    - name: Clone Git repository into web-server container
      shell: |
        kubectl exec {{ pod_name }} -c web-server -- bash -c "test -d /var/www/html/.git || git clone {{ git_repo_url }} /var/www/html"
      register: git_clone
      changed_when: git_clone.rc == 0
      when: git_check.rc == 0 or git_check.stdout != ""
      ignore_errors: true  # Continue if cloning fails

    # Step 5: Ensure no local changes in the git repository
    - name: Check the status of the git repository
      shell: |
        kubectl exec {{ pod_name }} -c web-server -- bash -c "cd /var/www/html && git status"
      register: git_status
      changed_when: false
      ignore_errors: true

    - name: Ensure no local changes in the repository
      assert:
        that:
          - '"nothing to commit" in git_status.stdout'
        fail_msg: "There are local changes in the repository, please commit or discard them before pulling."
      when: git_status.rc == 0

    # Step 6: Pull the latest changes from the GitHub repository
    - name: Pull latest changes from the Git repository
      shell: |
        kubectl exec {{ pod_name }} -c web-server -- bash -c "cd /var/www/html && git pull"
      when: '"nothing to commit" in git_status.stdout and git_status.rc == 0'
      ignore_errors: true

    # Step 7: Install Composer dependencies
    - name: Install Composer dependencies in the web-server container
      shell: |
        kubectl exec {{ pod_name }} -c web-server -- bash -c "cd /var/www/html && /usr/local/bin/composer install --no-dev --optimize-autoloader"
      register: composer_install
      changed_when: composer_install.rc == 0

    # Step 8: Install npm dependencies
    - name: Install npm dependencies in the web-server container
      shell: |
        kubectl exec {{ pod_name }} -c web-server -- bash -c "cd /var/www/html && npm install --production"
      register: npm_install
      changed_when: npm_install.rc == 0
      ignore_errors: true  # Continue if npm is not installed

    # Step 9: Run tests on SQLite database
    - name: Run tests on SQLite database in the web-server container
      shell: |
        kubectl exec {{ pod_name }} -c web-server -- bash -c "cd /var/www/html && php artisan test --env=testing"
      register: test_result
      ignore_errors: true  # Allow playbook to continue even if tests fail

    - name: Verify SQLite is being used in the test environment
      assert:
        that:
          - '"SQLite" in test_result.stdout'
        fail_msg: "The testing environment is not using SQLite."
        success_msg: "SQLite is confirmed in the testing environment."
      when: test_result.rc == 0

    # Step 10: Backup MySQL database
    - name: Backup the MySQL database in the mysql-db container
      shell: |
        kubectl exec {{ pod_name }} -c mysql-db -- bash -c "mysqldump -u root -p'{{ mysql_root_password }}' {{ mysql_database }} > /tmp/backup.sql"
      register: backup_result
      changed_when: backup_result.rc == 0

    - name: Copy backup file to local machine
      shell: |
        kubectl cp {{ pod_name }}:/tmp/backup.sql {{ backup_path }} -c mysql-db
      when: backup_result.rc == 0
      changed_when: true

    - name: Verify that the backup was created
      stat:
        path: "{{ backup_path }}"
      register: backup_status
      when: backup_result.rc == 0

    - name: Ensure the backup file exists
      assert:
        that:
          - backup_status.stat.exists
        fail_msg: "MySQL database backup failed, file not found."
        success_msg: "MySQL database backup created successfully."
      when: backup_result.rc == 0