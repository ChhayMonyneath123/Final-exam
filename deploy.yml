---
- name: Deploy and configure web server pod
  hosts: localhost
  gather_facts: no
  vars:
    pod_name: ""  # This will be set dynamically after retrieving the pod name
    mysql_root_password: "Hello@123"  # MySQL root password
    mysql_database: "ChhayMonyneath-db"  # Database name
    backup_path: "/home/neath/Documents/DevOps/Final-Exam/backup.sql"  # Backup file location
    git_repo_url: "https://github.com/ChhayMonyneath123/Final-exam.git"  # GitHub repository URL

  tasks:
    # Step 1: Get the current running pod name dynamically based on the label
    - name: Get the current running pod name
      shell: kubectl get pods -l app=laravel -o jsonpath='{.items[0].metadata.name}'
      register: current_pod
      changed_when: false
      failed_when: current_pod.rc != 0 or current_pod.stdout == ""

    - name: Debug pod name
      debug:
        msg: "Pod name retrieved: {{ current_pod.stdout }}"

    - name: Set the pod name variable
      set_fact:
        pod_name: "{{ current_pod.stdout }}"

    - name: Display the pod name
      debug:
        msg: "Working with pod: {{ pod_name }}"

    # Step 2: Check if Composer is installed in the web-server container
    - name: Check if Composer is installed
      shell: |
        kubectl exec {{ pod_name }} -c web-server -- bash -c "command -v composer"
      register: composer_check
      changed_when: false
      ignore_errors: true

    # Step 3: Install Composer if not found
    - name: Install Composer in the web-server container
      shell: |
        kubectl exec {{ pod_name }} -c web-server -- bash -c "curl -sS https://getcomposer.org/installer | php && mv composer.phar /usr/local/bin/composer"
      when: composer_check.rc != 0 or composer_check.stdout == ""
      changed_when: true

    # Step 4: Install Composer dependencies
    - name: Install Composer dependencies in the web-server container
      shell: |
        kubectl exec {{ pod_name }} -c web-server -- bash -c "cd /var/www/html && /usr/local/bin/composer install --no-dev --optimize-autoloader"
      register: composer_install
      changed_when: composer_install.rc == 0

    # Step 5: Check if npm is installed in the web-server container
    - name: Check if npm is installed
      shell: |
        kubectl exec {{ pod_name }} -c web-server -- bash -c "command -v npm"
      register: npm_check
      changed_when: false
      ignore_errors: true

    # Step 6: Install npm if not found
    - name: Install npm in the web-server container
      shell: |
        kubectl exec {{ pod_name }} -c web-server -- bash -c "apt-get update && apt-get install -y npm"
      when: npm_check.rc != 0 or npm_check.stdout == ""
      changed_when: true
      ignore_errors: true  # Some containers may not support apt-get

    # Step 7: Install npm dependencies
    - name: Install npm dependencies in the web-server container
      shell: |
        kubectl exec {{ pod_name }} -c web-server -- bash -c "cd /var/www/html && npm install --production"
      register: npm_install
      changed_when: npm_install.rc == 0
      when: npm_check.rc == 0 or npm_check.stdout != ""

    # Step 8: Run tests on SQLite database
    - name: Run tests on SQLite database in the web-server container
      shell: |
        kubectl exec {{ pod_name }} -c web-server -- bash -c "cd /var/www/html && php artisan test --env=testing"
      register: test_result
      ignore_errors: true  # Allow playbook to continue even if tests fail

    - name: Verify SQLite is being used in the test environment
      assert:
        that:
          - "'SQLite' in test_result.stdout"
        fail_msg: "The testing environment is not using SQLite."
        success_msg: "SQLite is confirmed in the testing environment."
      when: test_result.rc == 0

    # Step 9: Backup MySQL database
    - name: Backup the MySQL database in the mysql-db container
      shell: |
        kubectl exec {{ pod_name }} -c mysql-db -- bash -c "mysqldump -u root -p'{{ mysql_root_password }}' {{ mysql_database }} > {{ backup_path }}"
      when: test_result.rc == 0 and "'SQLite' in test_result.stdout"
      register: backup_result
      changed_when: backup_result.rc == 0

    # Step 10: Copy backup file to local machine
    - name: Copy MySQL backup to local backup path
      shell: |
        kubectl cp {{ pod_name }}:{{ backup_path }} {{ backup_path }} -c mysql-db
      when: backup_result.rc == 0
      changed_when: true

    # Step 11: Verify that the backup was created
    - name: Verify that the backup file exists
      stat:
        path: "{{ backup_path }}"
      register: backup_status
      when: backup_result.rc == 0

    - name: Ensure the backup file exists
      assert:
        that:
          - backup_status.stat.exists
        fail_msg: "MySQL database backup failed, file not found."
        success_msg: "MySQL database backup created successfully."
      when: backup_result.rc == 0